# 软件工程设计过程方法论
在 SICP 中，老师详细讲解了关于构建系统的结构

一种更普遍的观点是将其视作创建一种语言

将工程设计过程看作是创建一门语言

准确来说 是创建各种层次的语言

分为两种方法学
- 神话学（基于任务拆分（tasking）来实现）
- 分层构建

## 神话学
先找到要做的大任务，然后由这个大任务拆分出几个小任务，然后搞定小任务，小任务也可以继续的去拆分，然后这个任务搞定后回到之前的任务，继续搞定。最终完成整个任务

其实这样拆分没有问题，但是其中有一个很大的局限性

不稳定

为什么不稳定呢？是因为如果其中的一个任务有变化，那么它会影响到当前变化任务点下面所有的任务

> 如果用画图来表示的话 应该是个 tree 结构

所以说，任务拆分虽好，但是也要分场景的，哈哈，突然想到没有银弹这句话。

在设计一个软件工程上来说，任务拆分的局限性看起来还是有点大的

不过如果写一些小的程序来说，任务拆分还是很适合的。

## 基于层次

一个程序设计上有不同的层次

不同的层次对应的抽象层次是不同的

每个层次解决的问题也是不一样的

> 如果画图来表示的话，是个不断分层的结构

比如，我们可以利用语言给我们提供的基础元素进行组合，然后抽象成一个层次，专门处理基础元素，称之为层次A

然后在从层次A的基础上在进行组合以及抽象，称之为层次B

我们还可以继续扩展，不同的层次解决的问题是不一样的。都有它自己的关注点

这样的话，整个设计就变成了拼积木，十分灵活和稳定

每一个抽象组合出来的层次都可以看成是一个元素

只不过不同的元素有大有小，解决的问题也是不同的

下面就厉害了

每一层都可以看成一个语言，抽象出来的元素都可以看成当前抽象层级的基础元素

然后又可以在这个基础上进行组合和抽象

每一层的元素都是前一个层次所建立的！

着就能理解为什么将工程设计过程看作是创建一门语言（准确来说 是创建各种层次的语言）



## 区别

任务拆分的话是完成一个确定的任务 

如果其中一个任务点变化了，那么就会影响别的划分好的任务点

而分层是在每个层次上的完完全全的语言层面的能力，这里的每一个层次，都不是被设计为完成一个特定的任务，它被设计为考虑解决整个事情

这样的设计方法就变得更加健壮（因为不针对一个特定的任务）

当需要改变一个需求的时候，只需要用上一层语言实现的方法改变即可

因为每一层都是很独立的

## 分解观点
分解观点最大的不同在于，是按照层次还是严格继承分解

当你有了多个层次的语言时，你就有了不同的词汇储备，用于讨论不同层次上的设计

## 结论
所以如果我们想真的设计一个大的程序的话，采用分层显然要比任务拆分更加的灵活以及健壮

当我们只需要实现一个小的程序的时候，其实任务拆分完全可以胜任









